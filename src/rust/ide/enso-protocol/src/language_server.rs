//! Client library for the Language Server part of the Enso Protocol.
//!
//! Please refer to https://github.com/luna/enso/blob/master/doc/language-server/specification/enso-protocol.md#protocol-message-specification---language-server
//! for the full protocol documentation and discussion on the types and terms used here.
//!
//! Also, the Enso Protocol specification is source for many names and comments used here.
//! This file tries to follow the scheme of the protocol specification.

//TODO[dg]: Ask clarification about missing docs to Engine team.

use crate::prelude::*;

use crate::types::UTCDateTime;
use crate::types::Sha3_224;

use json_rpc::api::Result;
use json_rpc::Handler;
use json_rpc::make_rpc_methods;
use futures::Stream;
use serde::Serialize;
use serde::Deserialize;
use std::future::Future;
use uuid::Uuid;



// =============
// === Event ===
// =============

/// Event emitted by the Language Server `Client`.
pub type Event = json_rpc::handler::Event<Notification>;



// ============
// === Path ===
// ============

/// A path is a representation of a path relative to a specified content root.
// FIXME [mwu] Consider rename to something like `FilePath`, see https://github.com/luna/enso/issues/708
#[derive(Clone,Debug,Serialize,Deserialize,Hash,PartialEq,Eq)]
#[serde(rename_all = "camelCase")]
pub struct Path {
    /// Path's root id.
    pub root_id:Uuid,
    /// Path's segments.
    pub segments:Vec<String>,
}

impl Display for Path {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "//{}/", self.root_id)?;
        write!(f, "{}", self.segments.join("/"))
    }
}



// ====================
// === Notification ===
// ====================

/// Notification generated by the Language Server.
#[derive(Clone,Debug,PartialEq)]
#[derive(Serialize,Deserialize)]
#[serde(tag="method", content="params")]
pub enum Notification {
    /// Filesystem event occurred for a watched path.
    #[serde(rename = "file/event")]
    FileEvent {
        /// The `file/event` notification input wrapper.
        /// The serialization format requires the information to be wrapped into a field named "event".
        /// This behavior is currently not specified by the specification and the issue has been raised
        /// to address this: https://github.com/luna/enso/issues/707
        // TODO [mwu] Update as the issue is resolved on way or another.
        event:FileEvent,
    }
}



// =================
// === FileEvent ===
// =================

/// The `file/event` notification parameters.
#[derive(Clone,Debug,PartialEq)]
#[derive(Serialize,Deserialize)]
#[allow(missing_docs)]
pub struct FileEvent {
    pub path : Path,
    pub kind : FileEventKind,
}

/// Describes kind of filesystem event (was the file created or deleted, etc.)
#[derive(Clone,Copy,Debug,PartialEq)]
#[derive(Serialize,Deserialize)]
#[allow(missing_docs)]
pub enum FileEventKind {
    Added,
    Removed,
    Modified,
}



// ======================
// === FileAttributes ===
// ======================

/// Attributes of the file in the filesystem.
#[derive(Clone,Debug,PartialEq,Eq,Hash)]
#[derive(Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FileAttributes {
    /// When the file was created.
    pub creation_time:UTCDateTime,
    /// When the file was last accessed.
    pub last_access_time:UTCDateTime,
    /// When the file was last modified.
    pub last_modified_time:UTCDateTime,
    /// What kind of file is this.
    pub kind:FileSystemObject,
    /// Size of the file in bytes.
    /// (size of files not being `RegularFile`s is unspecified).
    pub byte_size:u64,
}

/// A representation of what kind of type a filesystem object can be.
#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(tag = "type")]
#[allow(missing_docs)]
pub enum FileSystemObject {
    Directory {
        name:String,
        path:Path,
    },
    /// A directory which contents have been truncated, i.e. with its subtree not listed
    /// any further due to depth limit being reached.
    // FIXME: To be clarified in https://github.com/luna/enso/issues/708
    DirectoryTruncated {
        name:String,
        path:Path,
    },
    File {
        name:String,
        path:Path,
    },
    /// Represents other, potenatially unrecognized object. Example is a broken symbolic link.
    // FIXME: To be clarified in https://github.com/luna/enso/issues/708
    Other {
        name:String,
        path:Path,
    },
    /// Represents a symbolic link that creates a loop.
    SymlinkLoop {
        name:String,
        path:Path,
        /// A target of the symlink. Since it is a loop, target is a subpath of the symlink.
        target: Path,
    }
}



// =================
// === Responses ===
// =================

/// Helper structures wrapping RPC method result types.
pub mod response {
    use super::*;

    /// Response of `init_protocol_connection` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    #[serde(rename_all = "camelCase")]
    pub struct InitProtocolConnection {
        /// List of Root IDs.
        pub content_roots:Vec<Uuid>,
    }

    /// Response of `file_read` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    pub struct Read {
        #[allow(missing_docs)]
        pub contents:String,
    }

    /// Response of `file_exists` method.
    #[derive(Hash,Debug,Clone,Copy,PartialEq,Eq,Serialize,Deserialize)]
    pub struct FileExists {
        #[allow(missing_docs)]
        pub exists:bool,
    }

    /// Response of `file_lst` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    pub struct FileList {
        #[allow(missing_docs)]
        pub paths:Vec<FileSystemObject>,
    }

    /// Response of `file_info` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    pub struct FileInfo {
        #[allow(missing_docs)]
        pub attributes: FileAttributes,
    }

    /// Response of `open_text_file` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[allow(missing_docs)]
    pub struct OpenTextFile {
        pub write_capability : Option<CapabilityRegistration>,
        pub content          : String,
        pub current_version  : Sha3_224
    }

    /// Response of `create_execution_context` method.
    #[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[allow(missing_docs)]
    pub struct CreateExecutionContext {
        pub can_modify       : CapabilityRegistration,
        pub receives_updates : CapabilityRegistration
    }
}



// ================
// === Position ===
// ================

/// A representation of a position in a text file.
#[derive(Hash,Debug,Clone,Copy,PartialEq,Eq,Serialize,Deserialize)]
#[allow(missing_docs)]
pub struct Position {
    pub line      : u32,
    pub character : u32
}



// =================
// === TextRange ===
// =================

/// A representation of a range of text in a text file.
#[derive(Hash,Debug,Clone,Copy,PartialEq,Eq,Serialize,Deserialize)]
#[allow(missing_docs)]
pub struct TextRange {
    pub start : Position,
    pub end   : Position
}


// ================
// === TextEdit ===
// ================

/// A representation of a change to a text file at a given position.
#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct TextEdit {
    pub range : TextRange,
    pub text  : String
}



// ================
// === FileEdit ===
// ================

/// A versioned representation of batch edits to a file.

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct FileEdit {
    pub path        : Path,
    pub edits       : Vec<TextEdit>,
    pub old_version : Sha3_224,
    pub new_version : Sha3_224
}



// ========================
// === ExecutionContext ===
// ========================

/// Execution context ID.
pub type ContextId = Uuid;

/// Execution context expression ID.
pub type ExpressionId = Uuid;

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VisualisationConfiguration {
    pub execution_context_id : Uuid,
    pub visualisation_module : String,
    pub expression           : String
}

#[derive(Hash,Debug,Clone,Copy,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct LocalCall {
    pub expression_id : ExpressionId
}

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct MethodPointer {
    pub file            : Path,
    pub defined_on_type : String,
    pub name            : String
}

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct ExplicitCall {
    pub method_pointer                  : MethodPointer,
    pub this_argument_expression        : Option<String>,
    pub positional_arguments_expression : Vec<String>
}

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[allow(missing_docs)]
pub enum StackItem {
    ExplicitCall(ExplicitCall),
    LocalCall(LocalCall)
}


// ==============================
// === CapabilityRegistration ===
// ==============================

#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(missing_docs)]
pub struct CapabilityRegistration {
    pub method           : String,
    pub register_options : RegisterOptions
}



// =======================
// === RegisterOptions ===
// =======================

/// `capability/acquire` takes method and options specific to the method. This type represents the
/// options. The used variant must match the method. See for details:
/// https://github.com/luna/enso/blob/master/doc/language-server/specification/enso-protocol.md#capabilities
#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[serde(untagged, rename_all = "camelCase")]
#[allow(missing_docs)]

pub enum RegisterOptions {
    ReceivesTreeUpdates(ReceivesTreeUpdates),
    #[serde(rename_all = "camelCase")]
    ExecutionContextId{context_id:ContextId}
}

/// `RegisterOptions`' to receive file system tree updates.
#[derive(Hash,Debug,Clone,PartialEq,Eq,Serialize,Deserialize)]
#[allow(missing_docs)]
pub struct ReceivesTreeUpdates {
    pub path : Path
}



// ====================
// === API & Client ===
// ====================

make_rpc_methods! {
/// An interface containing all the available file management operations.
trait API {
    /// Initialize the connection used to send the textual protocol messages. This initialisation
    /// is important such that the client identifier can be correlated between the textual and data
    /// connections.
    #[MethodInput=InitProtocolInput,rpc_name="session/initProtocolConnection",
    result=init_protocol_connection_result,set_result=set_init_protocol_connection_result]
    fn init_protocol_connection(&self, client_id:Uuid) -> response::InitProtocolConnection;

    /// Copy a specified file system object to another location.
    #[MethodInput=CopyFileInput,rpc_name="file/copy",result=copy_file_result,
    set_result=set_copy_file_result]
    fn copy_file(&self, from:Path, to:Path) -> ();

    /// Delete the specified file system object.
    #[MethodInput=DeleteFileInput,rpc_name="file/delete",result=delete_file_result,
    set_result=set_delete_file_result]
    fn delete_file(&self, path:Path) -> ();

    /// Check if file system object exists.
    #[MethodInput=FileExistsInput,rpc_name="file/exists",result=file_exists_result,
    set_result=set_file_exists_result]
    fn file_exists(&self, path:Path) -> response::FileExists;

    /// List all file-system objects in the specified path.
    #[MethodInput=FileListInput,rpc_name="file/list",result=file_list_result,
    set_result=set_file_list_result]
    fn file_list(&self, path:Path) -> response::FileList;

    /// Move file system object to another location.
    #[MethodInput=MoveFileInput,rpc_name="file/move",result=move_file_result,
    set_result=set_move_file_result]
    fn move_file(&self, from:Path, to:Path) -> ();

    /// Reads file's content as a String.
    #[MethodInput=ReadFileInput,rpc_name="file/read",result=file_read_result,
    set_result=set_file_read_result]
    fn read_file(&self, path:Path) -> response::Read;

    /// Gets file system object's attributes information.
    #[MethodInput=FileInfoInput,rpc_name="file/info",result=file_info_result,
    set_result=set_file_info_result]
    fn file_info(&self, path:Path) -> response::FileInfo;

    /// Creates the specified file system object.
    #[MethodInput=CreateInput,rpc_name="file/create",result=create_result,
    set_result=set_create_result]
    fn create_file(&self, object:FileSystemObject) -> ();

    /// Writes String contents to a file in the specified path.
    #[MethodInput=FileWriteInput,rpc_name="file/write",result=file_write_result,
    set_result=set_file_write_result]
    fn write_file(&self, path:Path, contents:String) -> ();

    /// Acquire capability permission.
    #[MethodInput=AcquireCapabilityInput,rpc_name="capability/acquire",
    result=acquire_capability_result,set_result=set_acquire_capability_result]
    fn acquire_capability(&self, method:String, register_options:RegisterOptions) -> ();

    /// Open the specified file. If no user has write lock on the opened file, the write lock
    /// capability is granted to the caller.
    #[MethodInput=OpenTextFileInput,rpc_name="text/openFile",result=open_text_file_result,
    set_result=set_open_text_file_result]
    fn open_text_file(&self, path:Path) -> response::OpenTextFile;

    /// Informs the language server that a client has closed the specified file.
    #[MethodInput=CloseTextFileInput,rpc_name="text/closeFile",result=close_text_file_result,
    set_result=set_close_text_file_result]
    fn close_text_file(&self, path:Path) -> ();

    /// Save the specified file. It may fail if the user does not have permission to edit that file.
    #[MethodInput=SaveTextFileInput,rpc_name="text/save",result=save_text_file_result,
    set_result=set_save_text_file_result]
    fn save_text_file(&self, path:Path, current_version:Sha3_224) -> ();

    /// Apply edits to the specified text file. This operation may fail if the user does not
    /// have permission to edit the resources for which edits are sent. This failure may be partial,
    /// in that some edits are applied and others are not.
    #[MethodInput=ApplyTextFileEditInput,rpc_name="text/applyEdit",
    result=apply_text_file_edit_result,set_result=set_apply_text_file_edit_result]
    fn apply_text_file_edit(&self, edit:FileEdit) -> ();

    /// Create a new execution context. Return capabilities executionContext/canModify and
    /// executionContext/receivesUpdates containing freshly created ContextId
    #[MethodInput=CreateExecutionContextInput,rpc_name="executionContext/create",
    result=create_execution_context_result,set_result=set_create_execution_context_result]
    fn create_execution_context(&self) -> response::CreateExecutionContext;

    /// Destroy an execution context and free its resources.
    #[MethodInput=DestroyExecutionContextInput,rpc_name="executionContext/destroy",
    result=destroy_execution_context_result,set_result=set_destroy_execution_context_result]
    fn destroy_execution_context(&self, context_id:ContextId) -> ();

    /// Move the execution context to a new location deeper down the stack.
    #[MethodInput=PushExecutionContextInput,rpc_name="executionContext/push",
    result=push_execution_context_result,set_result=set_push_execution_context_result]
    fn push_execution_context(&self, context_id:ContextId, stack_item:StackItem) -> ();

    /// Move the execution context up the stack.
    #[MethodInput=PopExecutionContextInput,rpc_name="executionContext/pop",
    result=pop_execution_context_result,set_result=set_pop_execution_context_result]
    fn pop_execution_context(&self, context_id:ContextId) -> ();

    /// Attach a visualisation, potentially preprocessed by some arbitrary Enso code, to a given
    /// node in the program.
    #[MethodInput=AttachVisualisationInput,rpc_name="executionContext/attachVisualisation",
    result=attach_visualisation_result,set_result=set_attach_visualisation_result]
    fn attach_visualisation
    ( &self
    , visualisation_id     : Uuid
    , expression_id        : Uuid
    , visualisation_config : VisualisationConfiguration) -> ();

    /// Detach a visualisation from the executing code.
    #[MethodInput=DetachVisualisationInput,rpc_name="executionContext/detachVisualisation",
    result=detach_visualisation_result,set_result=set_detach_visualisation_result]
    fn detach_visualisation(&self, execution_context_id:Uuid, visualisation_id:Uuid) -> ();

    /// Modify the configuration for an existing visualisation.
    #[MethodInput=ModifyVisualisationInput,rpc_name="executionContext/modifyVisualisation",
    result=modify_visualisation_result,set_result=set_modify_visualisation_result]
    fn modify_visualisation
    (&self, visualisation_id:Uuid, visualisation_config:VisualisationConfiguration) -> ();
}}



// =============
// === Tests ===
// =============

#[cfg(test)]
mod tests {
    use super::*;

    use futures::task::LocalSpawnExt;
    use json_rpc::messages::Message;
    use json_rpc::messages::RequestMessage;
    use json_rpc::test_util::transport::mock::MockTransport;
    use serde_json::json;
    use serde_json::Value;
    use std::future::Future;
    use utils::test::poll_future_output;
    use utils::test::poll_stream_output;

    struct Fixture {
        transport : MockTransport,
        client    : Client,
        executor  : futures::executor::LocalPool,
    }

    fn setup_language_server() -> Fixture {
        let transport = MockTransport::new();
        let client    = Client::new(transport.clone());
        let executor  = futures::executor::LocalPool::new();
        executor.spawner().spawn_local(client.runner()).unwrap();
        Fixture {transport,client,executor}
    }

    #[test]
    fn test_file_event_notification() {
        let mut fixture = setup_language_server();
        let mut events  = Box::pin(fixture.client.events());
        assert!(poll_stream_output(&mut events).is_none());

        let root_id = uuid::Uuid::parse_str("00000000-0000-0000-0000-000000000000");
        let root_id = root_id.expect("Couldn't parse uuid.");
        let expected_event = FileEvent {
            path : Path{root_id,segments:vec!["Main.txt".into()]},
            kind : FileEventKind::Modified,
        };
        let notification_text = r#"{
            "jsonrpc": "2.0",
            "method": "file/event",
            "params": {
                "event" : {
                    "path" : {
                        "rootId"   : "00000000-0000-0000-0000-000000000000",
                        "segments" : ["Main.txt"]
                    },
                    "kind" : "Modified"
                }
            }
        }"#;
        fixture.transport.mock_peer_message_text(notification_text);
        assert!(poll_stream_output(&mut events).is_none());

        fixture.executor.run_until_stalled();

        let event = poll_stream_output(&mut events);
        if let Some(Event::Notification(n)) = event {
            assert_eq!(n, Notification::FileEvent {event:expected_event});
        } else {
            panic!("expected notification event");
        }
    }

    /// This function tests making a request using language server. It
    /// * creates FM client and uses `make_request` to make a request,
    /// * checks that request is made for `expected_method`,
    /// * checks that request input is `expected_input`,
    /// * mocks receiving a response from server with `result` and
    /// * checks that FM-returned Future yields `expected_output`.
    fn test_request<Fun, Fut, T>
    ( make_request:Fun
    , expected_method:&str
    , expected_input:Value
    , result:Value
    , expected_output:T )
    where Fun : FnOnce(&mut Client) -> Fut,
          Fut : Future<Output = Result<T>>,
          T   : Debug + PartialEq {
        let mut fixture        = setup_language_server();
        let mut request_future = Box::pin(make_request(&mut fixture.client));

        let request = fixture.transport.expect_message::<RequestMessage<Value>>();
        assert_eq!(request.method, expected_method);
        assert_eq!(request.params, expected_input);

        let response = Message::new_success(request.id, result);
        fixture.transport.mock_peer_message(response);
        fixture.executor.run_until_stalled();
        let output = poll_future_output(&mut request_future).unwrap().unwrap();
        assert_eq!(output, expected_output);
    }

    #[test]
    fn test_file_requests() {
        let root_id   = uuid::Uuid::parse_str("00000000-0000-0000-0000-000000000000");
        let root_id   = root_id.expect("Couldn't parse uuid.");
        let main      = Path { root_id, segments: vec!["Main.txt".into()] };
        let target    = Path { root_id, segments: vec!["Target.txt".into()] };
        let path_main = json!({"path" : {
                "rootId"   : "00000000-0000-0000-0000-000000000000",
                "segments" : ["Main.txt"]
            }
        });
        let from_main_to_target = json!({
            "from" : {
                "rootId"   : "00000000-0000-0000-0000-000000000000",
                "segments" : ["Main.txt"]
            },
            "to" : {
                "rootId"   : "00000000-0000-0000-0000-000000000000",
                "segments" : ["Target.txt"]
            }
        });
        let file_exists_json = json!({"exists":true});
        let unit_json = json!(null);

        test_request(
            |client| client.copy_file(main.clone(), target.clone()),
            "file/copy",
            from_main_to_target.clone(),
            unit_json.clone(),
            ());
        test_request(
            |client| client.delete_file(main.clone()),
            "file/delete",
            path_main.clone(),
            unit_json.clone(),
            ());
        test_request(
            |client| client.file_exists(main.clone()),
            "file/exists",
            path_main.clone(),
            file_exists_json,
            response::FileExists { exists: true });

        let list_response_json = json!({
            "paths" : [
                {
                    "type" : "File",
                    "name" : "foo.txt",
                    "path" : {
                        "rootId"   : "00000000-0000-0000-0000-000000000000",
                        "segments" : []
                    }
                },
                {
                    "type" : "File",
                    "name" : "bar.txt",
                    "path" : {
                        "rootId"   : "00000000-0000-0000-0000-000000000000",
                        "segments" : []
                    }
                }
            ]
        });
        let list_response_value = response::FileList {
            paths: vec![
                FileSystemObject::File {
                    name : "foo.txt".into(),
                    path : Path { root_id, segments: default() }
                },
                FileSystemObject::File {
                    name : "bar.txt".into(),
                    path : Path { root_id, segments: default() }
                }
            ]
        };
        test_request(
            |client| client.file_list(main.clone()),
            "file/list",
            path_main.clone(),
            list_response_json,
            list_response_value);
        test_request(
            |client| client.move_file(main.clone(), target.clone()),
            "file/move",
            from_main_to_target.clone(),
            unit_json.clone(),
            ());

        let read_response_json = json!({"contents":"Hello world!"});
        let read_response = response::Read { contents: "Hello world!".into() };
        test_request(
            |client| client.read_file(main.clone()),
            "file/read",
            path_main.clone(),
            read_response_json,
            read_response);

        let parse_rfc3339 = |s| {
            chrono::DateTime::parse_from_rfc3339(s).unwrap()
        };
        let file_system_object = FileSystemObject::File {
            name: "test.txt".into(),
            path: Path {
                root_id,
                segments: default()
            }
        };
        let file_system_object_json = json!({
            "type" : "File",
            "name" : "test.txt",
            "path" : {
                "rootId"   : "00000000-0000-0000-0000-000000000000",
                "segments" : []
            }
        });
        let expected_attributes = response::FileInfo { attributes : FileAttributes {
            creation_time      : parse_rfc3339("2020-01-07T21:25:26Z"),
            last_access_time   : parse_rfc3339("2020-01-21T22:16:51.123994500+00:00"),
            last_modified_time : parse_rfc3339("2020-01-07T21:25:26Z"),
            kind               : file_system_object.clone(),
            byte_size          : 125125,
        }};
        let sample_attributes_json = json!({ "attributes" : {
            "creationTime"     : "2020-01-07T21:25:26Z",
            "lastAccessTime"   : "2020-01-21T22:16:51.123994500+00:00",
            "lastModifiedTime" : "2020-01-07T21:25:26Z",
            "kind"             : file_system_object_json,
            "byteSize" : 125125
        }});
        test_request(
            |client| client.file_info(main.clone()),
            "file/info",
            path_main.clone(),
            sample_attributes_json,
            expected_attributes);
        let create_file_json = json!({
            "object" : file_system_object_json
        });
        test_request(
            |client| client.create_file(file_system_object),
            "file/create",
            create_file_json.clone(),
            unit_json.clone(),
            ());
        test_request(
            |client| client.write_file(main.clone(), "Hello world!".into()),
            "file/write",
            json!({
                "path" : {
                    "rootId"   : "00000000-0000-0000-0000-000000000000",
                    "segments" : ["Main.txt"]
                },
                "contents" : "Hello world!"
            }),
            unit_json.clone(),
            ());
        let init_protocol_connection_response = response::InitProtocolConnection {
            content_roots : vec![uuid::Uuid::default()]
        };
        test_request(
            |client| client.init_protocol_connection(uuid::Uuid::default()),
            "session/initProtocolConnection",
            json!({
                "clientId" : "00000000-0000-0000-0000-000000000000"
            }),
            json!({
                "contentRoots" : ["00000000-0000-0000-0000-000000000000"]
            }),
            init_protocol_connection_response
        );
        let path                  = Path{root_id,segments:default()};
        let receives_tree_updates = ReceivesTreeUpdates{path};
        let options               = RegisterOptions::ReceivesTreeUpdates(receives_tree_updates);
        test_request(
            |client| client.acquire_capability("receivesTreeUpdates".into(),options),
            "capability/acquire",
            json!({
                "method"          : "receivesTreeUpdates",
                "registerOptions" : {
                    "path" : {
                        "rootId"   : "00000000-0000-0000-0000-000000000000",
                        "segments" : []
                    }
                }
            }),
            unit_json.clone(),
            ()
        );
        let context_id       = uuid::Uuid::default();
        let method           = "executionContext/canModify".to_string();
        let register_options = RegisterOptions::ExecutionContextId{context_id};
        let can_modify       = CapabilityRegistration{method,register_options};
        let register_options = RegisterOptions::ExecutionContextId{context_id};
        let method           = "executionContext/receivesUpdates".to_string();
        let receives_updates = CapabilityRegistration{method,register_options};
        let create_execution_context_response = response::CreateExecutionContext
            {can_modify,receives_updates};
        test_request(
            |client| client.create_execution_context(),
            "executionContext/create",
            json!({}),
            json!({
                "canModify" : {
                    "method"          : "executionContext/canModify",
                    "registerOptions" : {
                        "contextId" : "00000000-0000-0000-0000-000000000000"
                    }
                },
                "receivesUpdates" : {
                    "method"          : "executionContext/receivesUpdates",
                    "registerOptions" : {
                        "contextId" : "00000000-0000-0000-0000-000000000000"
                    }
                }
            }),
            create_execution_context_response
        );
        test_request(
            |client| client.destroy_execution_context(context_id),
            "executionContext/destroy",
            json!({"contextId":"00000000-0000-0000-0000-000000000000"}),
            unit_json.clone(),
            ()
        );
        let expression_id = uuid::Uuid::default();
        let local_call    = LocalCall {expression_id};
        let stack_item    = StackItem::LocalCall(local_call);
        test_request(
            |client| client.push_execution_context(context_id,stack_item),
            "executionContext/push",
            json!({
                "contextId" : "00000000-0000-0000-0000-000000000000",
                "stackItem" : {
                    "LocalCall" : {
                        "expressionId" : "00000000-0000-0000-0000-000000000000"
                    }
                }
            }),
            unit_json.clone(),
            ()
        );
        test_request(
            |client| client.pop_execution_context(context_id),
            "executionContext/pop",
            json!({"contextId":"00000000-0000-0000-0000-000000000000"}),
            unit_json.clone(),
            ()
        );
        let visualisation_id     = uuid::Uuid::default();
        let expression_id        = uuid::Uuid::default();
        let expression           = "1 + 1".to_string();
        let visualisation_module = "[Foo.Bar.Baz]".to_string();
        let visualisation_config = VisualisationConfiguration
            {execution_context_id:context_id,expression,visualisation_module};
        test_request(
            |client|
                client.attach_visualisation(visualisation_id,expression_id,visualisation_config),
            "executionContext/attachVisualisation",
            json!({
                "visualisationId"     : "00000000-0000-0000-0000-000000000000",
                "expressionId"        : "00000000-0000-0000-0000-000000000000",
                "visualisationConfig" : {
                    "executionContextId"  : "00000000-0000-0000-0000-000000000000",
                    "visualisationModule" : "[Foo.Bar.Baz]",
                    "expression"          : "1 + 1"
                }
            }),
            unit_json.clone(),
            ()
        );
        test_request(
            |client| client.detach_visualisation(context_id,visualisation_id),
            "executionContext/detachVisualisation",
            json!({
                "executionContextId" : "00000000-0000-0000-0000-000000000000",
                "visualisationId"    : "00000000-0000-0000-0000-000000000000"
            }),
            unit_json.clone(),
            ()
        );
        let expression           = "1 + 1".to_string();
        let visualisation_module = "[Foo.Bar.Baz]".to_string();
        let visualisation_config = VisualisationConfiguration
        {execution_context_id:context_id,expression,visualisation_module};
        test_request(
            |client| client.modify_visualisation(visualisation_id,visualisation_config),
            "executionContext/modifyVisualisation",
            json!({
                "visualisationId"     : "00000000-0000-0000-0000-000000000000",
                "visualisationConfig" : {
                    "executionContextId"  : "00000000-0000-0000-0000-000000000000",
                    "visualisationModule" : "[Foo.Bar.Baz]",
                    "expression"          : "1 + 1"
                }
            }),
            unit_json.clone(),
            ()
        );
        let content               = b"Hello World!";
        let current_version       = Sha3_224::new(content);
        let content               = String::from_utf8_lossy(content).to_string();
        let method                = "text/canEdit".to_string();
        let receives_tree_updates = ReceivesTreeUpdates{path:main.clone()};
        let register_options      = RegisterOptions::ReceivesTreeUpdates(receives_tree_updates);
        let write_capability      = Some(CapabilityRegistration{method,register_options});
        let open_text_file_response = response::OpenTextFile
            {content,current_version:current_version.clone(),write_capability};
        test_request(
            |client| client.open_text_file(main.clone()),
            "text/openFile",
            json!({
                "path" : {
                    "rootId"   : "00000000-0000-0000-0000-000000000000",
                    "segments" : ["Main.txt"]
                }
            }),
            json!({
                "writeCapability" : {
                    "method"         : "text/canEdit",
                    "registerOptions": {
                        "path" : {
                            "rootId"   : "00000000-0000-0000-0000-000000000000",
                            "segments" : ["Main.txt"]
                        }
                    }
                },
                "content"        : "Hello World!",
                "currentVersion" : "716596afadfa17cd1cb35133829a02b03e4eed398ce029ce78a2161d"
            }),
            open_text_file_response
        );
        let start       = Position{line:0,character:5};
        let end         = Position{line:0,character:5};
        let range       = TextRange{start,end};
        let text        = ",".to_string();
        let text_edit   = TextEdit{range,text};
        let edits       = vec![text_edit];
        let old_version = Sha3_224::new(b"Hello world!");
        let new_version = Sha3_224::new(b"Hello, world!");
        let path        = main.clone();
        let edit        = FileEdit {path,edits,old_version,new_version:new_version.clone()};
        test_request(
            |client| client.apply_text_file_edit(edit),
            "text/applyEdit",
            json!({
                "edit" : {
                    "path" : {
                        "rootId"   : "00000000-0000-0000-0000-000000000000",
                        "segments" : ["Main.txt"]
                    },
                    "edits" : [
                        {
                            "range" : {
                                "start" : {
                                    "line"      : 0,
                                    "character" : 5
                                },
                                "end" : {
                                    "line"      : 0,
                                    "character" : 5
                                }
                            },
                            "text" : ","
                        }
                    ],
                    "oldVersion" : "d3ee9b1ba1990fecfd794d2f30e0207aaa7be5d37d463073096d86f8",
                    "newVersion" : "6a33e22f20f16642697e8bd549ff7b759252ad56c05a1b0acc31dc69"
                }
            }),
            unit_json.clone(),
            ()
        );
        test_request(
            |client| client.save_text_file(main.clone(),current_version),
            "text/save",
            json!({
                "path" : {
                    "rootId"   : "00000000-0000-0000-0000-000000000000",
                    "segments" : ["Main.txt"]
                },
                "currentVersion" : "716596afadfa17cd1cb35133829a02b03e4eed398ce029ce78a2161d"
            }),
            unit_json.clone(),
            ()
        );
        test_request(
            |client| client.close_text_file(main),
            "text/closeFile",
            json!({
                "path" : {
                    "rootId"   : "00000000-0000-0000-0000-000000000000",
                    "segments" : ["Main.txt"]
                }
            }),
            unit_json,
            ()
        );
    }
}
